<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - GLTFloader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			
.progress-bar-container{
	position: absolute;
	left: 40%;
	top: 50%;
	
	width: 100%;
	height: 100%;
	
	justify-content: center;
	  /*
	  transform: translate((-50%,-50%));
	 */
  }
  #progress-bar{
	width: 30%;
	margin-top: 0.5%;
	height: 2%;
	
  }
  select {
        position: absolute;
        z-index: 1;
        top: 1em;
        right: 1em;
      }
		</style>
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader<br />
			Battle Damaged Sci-fi Helmet by
			<a href="https://sketchfab.com/theblueturtle_" target="_blank" rel="noopener">theblueturtle_</a><br />
			<a href="https://hdrihaven.com/hdri/?h=royal_esplanade" target="_blank" rel="noopener">Royal Esplanade</a> by <a href="https://hdrihaven.com/" target="_blank" rel="noopener">HDRI Haven</a>
		</div>

		<div class="progress-bar-container">
			<progress id="progress-bar" value="0" max="100"></progress>
		  </div>
		  <select id='api'>
			<option value=''>- Choose an API -</option>
			<option value='webgl'>WebGL</option>			
			<option value='webgpu' selected>WebGPU</option>
		  </select>
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
				  "three": "../build/three.module.js",
				  "three/addons/": "./jsm/",
				  "three/nodes": "./jsm/nodes/Nodes.js"
				}
			  }
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { RGBELoader } from './jsm/loaders/RGBELoader.js';		
			let camera,controls, scene, renderer,gltf;
			import {
				AmbientLight ,
				Color 
				} from "three";
			import WebGPURenderer from './jsm/renderers/webgpu/WebGPURenderer.js';				
			 import WebGPU from './jsm/capabilities/WebGPU.js'
			 import {toneMapping } from 'three/nodes';
			init();
			render();

			function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU support' );

					}

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( - 1.8, 0.6, 2.7 );
				
				scene = new THREE.Scene();
				scene.add(camera)
				let ambientLightSun = new AmbientLight();
				ambientLightSun.color = new Color(0xffffff);
				ambientLightSun.intensity = 10;
				scene.add(ambientLightSun);
				ambientLightSun.name = "ambientLightSun"
				const progressBar=document.getElementById("progress-bar");

				const manager = new THREE.LoadingManager();
				manager.onStart = function ( url, itemsLoaded, itemsTotal ) {

				console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

				};
				manager.onLoad = function () {
				console.log( 'Loading complete!');
				progressBar.style.display = "none";

				};
				manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {

				console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
				progressBar.value=(itemsLoaded/itemsTotal)*100;
				};		
				manager.onError = function ( url ) {

				console.log( 'There was an error loading ' + url );

				};
								 
const apiSelect = document.getElementById('api');
async function onApiChange() {
        let prevCanvas;
        if (renderer) {
          prevCanvas = renderer.canvas;
          //renderer.stop();		  
        //   camera.element = null;
        }

        switch(apiSelect.value) {
          case 'webgl':
            renderer = new THREE.WebGLRenderer( { antialias: true } )
			renderer.setSize( window.innerWidth, window.innerHeight );
            break;
          /* case 'webgl2':
            renderer = new WebGL2Renderer();
            break; */
          case 'webgpu':
            renderer = new WebGPURenderer();
            break;
          default:
            renderer = null;
            if (prevCanvas) {
              document.body.removeChild(prevCanvas);
            }
            break;
        }

        if (renderer) {
          try {
//            await renderer.init();

            // renderer.setStats(stats);
          /*   if (gltf) {
              await renderer.setGltf(gltf);
            } */
            // renderer.camera = camera;
            if (prevCanvas) {
              document.body.removeChild(prevCanvas);
            }
            document.body.appendChild(renderer.domElement);
            // camera.element = renderer.canvas;
			render()
            // renderer.start();
          } catch (err) {
            console.error('renderer init failed', err);
            // renderer.stop();			
            renderer = null;
          }
        }
      }
      apiSelect.addEventListener('change', onApiChange);
      onApiChange();

	  async function initGltf() {
		const loader = new GLTFLoader(manager).setPath( 'models/gltf/DamagedHelmet/glTF/' );
						loader.load( 'DamagedHelmet.gltf', function ( glb ) {

							scene.add( glb.scene );							

							render();

						}
						
						 );       
      }
      initGltf();

				new RGBELoader(manager)
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.background = texture;
						scene.environment = texture;
						controls = new OrbitControls( camera, renderer.domElement );
						controls.addEventListener( 'change', render ); // use if there is no animation loop
						controls.minDistance = 2;
						controls.maxDistance = 10;
						controls.target.set( 0, 0, - 0.2 );
						controls.update();
						render(); 
					})						
				container.appendChild( renderer.domElement ); 

				
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				
				render();

			}

			//

			function render() {

				renderer.render( scene, camera );							
			}

		</script>

	</body>
</html>
